class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        //Track count for each one
        int size = graph.length;
        //Color of each Node
        int[] colorOfNode = new int [size];
        Arrays.fill(colorOfNode, -1);
        //Size of Each Color
        Set<Integer> initialSet = new HashSet<>();
        for(int i : initial) initialSet.add(i);
        int c = 0;
        for(int i = 0; i < size; i++) {
            if(colorOfNode[i] > -1) continue;
            dfs(i, graph, initial, colorOfNode, c++);
        }
        int[] colorSize = new int[c];
        int[] dupeCheck = new int[c];
        for(int i = 0; i < size; i++) {
            colorSize[colorOfNode[i]]++;
            if(initialSet.contains(i)) dupeCheck[colorOfNode[i]]++;
        }
        int max = -1;
        int ansIdx = -1;
        Arrays.sort(initial);
        for(int i : initial) {
            //System.out.println(i + " : "  + dupeCheck[colorOfNode[i]] +  " : " + colorSize[colorOfNode[i]]);
            if(dupeCheck[colorOfNode[i]] == 1 && colorSize[colorOfNode[i]] > max) {
                max = colorSize[colorOfNode[i]];
                ansIdx = i;
            }
        }
        if(ansIdx == -1) return initial[0];
        return ansIdx;

    }
    private void dfs(int i, int[][] graph, int[] initial, int[] color, int c) {
        //Count any possible edges this can visit
        color[i] = c;
        for(int j = 0; j < graph.length; j++) {
            int edge = graph[i][j];
            if(edge == 1 && color[j] == -1) {
                dfs(j, graph, initial, color, c);
            }
        }
    }
}